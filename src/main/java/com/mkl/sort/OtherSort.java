package com.mkl.sort;

/**
 * @author 马锴梁
 * @version 1.0
 * @date 2019/12/9 10:45
 */
public class OtherSort {
//    1.桶排序
//    如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。
//    每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k
//    * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近
//    数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。
//    2.计数排序
//    计数排序是桶排序的一种特殊情况
//    我们都经历过高考，高考查分数系统你还记得吗？我们查分数的时候，系统会显示我们的成绩以及所
//    在省的排名。如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？考生的满分是 900
//    分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分
//    。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所
//    以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了
//    50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。
//    3.基数排序
//    10 万个手机号码，希望将这 10 万个手机号码从小到大排序
//    将11位电话号码拆成int[11]，只要比较相同位数的值的大小即可得出两个电话大小
}
